# Relevant information on code blocks and syntax highlighting
#
# Markdown-it uses mdit-py-plugins as a plugin system to extend its functionality.
# pip3 install mdit-py-plugins
# https://mdit-py-plugins.readthedocs.io/en/latest/#mdit-py-plugins-package
#
# Markdown-it uses pygments as a backend engine for syntax highlighting.
# pip3 install pygments
# 
# The 'fence' token type is used to represent code blocks in Markdown.
# Related to Markdown-it: 
# https://github.com/markdown-it/markdown-it/blob/master/docs/architecture.md
# https://markdown-it.github.io/markdown-it/#Renderer
# https://github.com/markdown-it/markdown-it/tree/master/docs
#
# For the pygments styles available:
# https://pygments.org/styles/
# https://pygments.org/docs/styles/
#
# To successfully match the html CSS classes created by the pygments_highlight() function with the CSS file created by Pygments, the CSS file must be create as follows: 
# pygmentize -S gruvbox-dark -f html -a .highlight > pygments-gruvbox-dark.css
# where -S reference the style, and  -a .highlight is the class name that will be used in the HTML file to apply the style
# then the class have to be properly specified in the pygments_highlight() function as follows:
# formatter = HtmlFormatter(style='gruvbox-dark', cssclass = 'terror', linenos=True) 
# in case the interest is not to use the colors defined in the CSS file, 
# formatter.noclasses = True, this will set the function to default and use the style provided on 
# formatter = HtmlFormatter(style='gruvbox-light', cssclass = 'gruvebox-dark-style', linenos=True)
# in this case style='gruvbox-light', this will be provided inline CSS styles in the html generated by pygments_highlight()
# 
###############################################

from flask import Flask, render_template, request, jsonify
import os
from markdown_it import MarkdownIt
from pygments import highlight
from pygments.lexers import get_lexer_by_name, get_all_lexers
from pygments.formatters import HtmlFormatter
from mdit_py_plugins.tasklists import tasklists_plugin
from mdit_py_plugins.texmath import texmath_plugin  # Not working properly for the moment, currently using MathJax on the client side

app = Flask(__name__)

# Custom function for highlighting code blocks
def pygments_highlight(code, lang):
    try:
        # Get all available lexer names

        # DEBUGGING CONCLUSION FOR RENDERING BUT NOT HIGHLIGHTING ANY CODES!
        # Since get_all_lexers() returns a list of tuples with the lexer name and its aliases in MIXED case,
        # ['Hspec', 'HTML+Django/Jinja', 'HTML+Genshi', 'HTML', 'HTML+PHP', 'HTML+Smarty', 'HTTP', 'Hxml', 'Hy', 'Hybris', 'Java', 'JavaScript+Django/Jinja', 'JavaScript+Ruby']
        # the "if" statement below was failing because it couldn't make an exact match between the "lang" identified in "custom_fence_renderer"
        # (which is in lowercase) and the tuple from get_all_lexers() that contains mixed case!
        #
        # Note2: I could avoid all the hesitations with the lexer names in the pygments_highlight() function by 
        # just calling the PythonLexer() function from the pygments.lexers module, but... this bug teahed me a lot!
        # from pygments.lexers import PythonLexer
        # then in the return of the pygments_highlight() function:
        # return highlight(code, PythonLexer(), formatter)  
        #
        # Note3: I find out that the reason that pygments_highlight() function was identifying the "lang" as lowercase was that the file itself have the language name in lowercase!
        # ```python instead of ```Python


        # Creating a new tuple with the lexer names in lowercase
        available_lexers = [lexer[0].casefold() for lexer in get_all_lexers()]

        # print(f"Available lexers: {available_lexers}")  # Debugging

        # Check if the provided language exists in the available lexers
        if lang.casefold() in available_lexers:
            # print("DEBUGGING GETTING IN => IF")  # Debugging
            # print(f"Language '{lang}' found in available lexers.")  # Debugging
            lexer = get_lexer_by_name(lang, stripall=True)
        else:
            # print("DEBUGGING GETTING IN => ELSE")  # Debugging
            print(f"Language '{lang}' not found. Falling back to 'text' lexer.")  # Debugging
            lexer = get_lexer_by_name("text", stripall=True)
    except Exception:
        # print("DEBUGGING GETTING INTO Exception")  # Debugging
        lexer = get_lexer_by_name("text", stripall=True)  # Default language
        # lexer = get_lexer_by_name("python", stripall=True)  # Default language

    # Applying the style to the formatter

    # formatter = HtmlFormatter(style=get_style_by_name('gruvbox-light'), linenos=True, cssclass='codehilite')
    formatter = HtmlFormatter(style='dracula', cssclass = 'gruvebox-dark-style', linenos=True)
    formatter.noclasses = True
    # return highlight(code, PythonLexer(), formatter) # this works!
    return highlight(code, lexer, formatter)

# MarkdownIt with custom syntax highlighting
def markdown_with_syntax_highlighting(md_input):
    # md = MarkdownIt("gfm-like").enable('table')

    # Calling plugins to extend the functionality of MarkdownIt
    md = MarkdownIt("commonmark").enable('table').use(tasklists_plugin)
    # Since my texmath_plugin is failing to render the math equations, I will temporarily rely on the MathJax function
    # that is implemented on the client side of the application in Markdown-Reader.html
    # This means that all math equations will be rendered on the client side and not the server side
    """ md = (
    MarkdownIt("commonmark")
    .enable('table')
    .use(tasklists_plugin)
    .use(texmath_plugin, {"delimiters": "dollars"})  # Use $...$ for inline math and $$...$$ for block math 
    ) """
    # Custom renderer for code blocks
    def custom_fence_renderer(tokens, idx, options, env):
        # Debugging the arguments to ensure correct usage
        # print(f"Token info: {tokens[idx].info}")  # Debug: Language info
        # print(f"Token content: {tokens[idx].content}")  # Debug: Code block content
        # print(f"Tokens: {tokens}")  # Debugging
        # print(f"Index: {idx}")      # Debugging
        # print(f"Options: {options}")  # Debugging
        # print(f"Env: {env}")        # Debugging
        # print(f"Renderer: {renderer}") # Debugging

        token = tokens[idx]
        lang = token.info.strip() or "text"
        code = token.content
        # print(f"DEBUGGING Lang: {lang}")  # Debugging
        return pygments_highlight(code, lang)
    

    # Assigning the custom renderer to the 'fence' token type
    md.renderer.rules['fence'] = custom_fence_renderer
    return md.render(md_input)

@app.route('/', methods=['GET', 'POST'])
def editor():
    rendered_text = ""
    file_path = ""
    
    if request.method == 'POST':
        # Get the file path from the form
        file_path = request.form.get('file_path')
        print(f"Received file path: {file_path}")  # Debug here
        
        if file_path:
            try:
                # Check if the file path is valid
                if not os.path.exists(file_path):
                    app.logger.error(f"Invalid file path: {file_path}")
                    rendered_text = "Error: The file path is invalid or does not exist."
                else:
                    # Read the Markdown file
                    with open(file_path, 'r') as file:
                        markdown_input = file.read()
                        # print(f"Markdown file content: {markdown_input}")  # Debug here
                    
                    # Convert Markdown to HTML
                    rendered_text = markdown_with_syntax_highlighting(markdown_input)
                    # print(f"Rendered text: {rendered_text}")  # Debug here
                    
            except Exception as e:
                rendered_text = f"Error reading the file: {e}"

    # Render the page, either with or without the rendered text
    return render_template("Markdown-Reader.html", rendered_text=rendered_text, file_path=file_path)

@app.route('/update_preview', methods=['POST'])
def update_preview():
    # Print received data for debugging
    data = request.get_json()
    print(f"Data received via AJAX: {data}")
    
    file_path = data.get('file_path', "")
    
    if not file_path:
        app.logger.error("No file path provided in AJAX request.")
        
    elif file_path and os.path.exists(file_path):
        try:
            # Read the Markdown file
            with open(file_path, 'r') as file:
                markdown_input = file.read()
                
            # Convert Markdown to HTML
            rendered_text = markdown_with_syntax_highlighting(markdown_input)
            # print(f"Rendered text via AJAX: {rendered_text}")  # Debugging
            return rendered_text  # Return only the HTML of the rendered content
        except Exception as e:
            print(f"Error reading the file: {e}")
            return f"Error reading the file: {e}", 500
    else:
        print("Error: The file path is invalid or does not exist.")
        return "Error: The file path is invalid or does not exist.", 400

if __name__ == '__main__':
    app.run(debug=True)
